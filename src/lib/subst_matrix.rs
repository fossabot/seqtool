//! Simple substitution matrix for ambiguous DNA (only -1 or 1), asymmetric

pub struct AsymmIdentityDnaMatrix;

impl AsymmIdentityDnaMatrix {
    const IDX: [u8; 256] = [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 14, 1, 13,
        16, 16, 2, 12, 16, 16, 10, 16, 5, 15, 16, 16, 16, 6, 8, 3, 4, 11, 7, 16, 9, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16,
    ];
    const MATRIX: [i8; 289] = [
    // 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
    // A   C   G   T   U   M   R   W   S   Y   K   V   H   D   B   N   ?
       1, -1, -1, -1, -1,  1,  1,  1, -1, -1, -1,  1,  1,  1, -1,  1, -1,   // A
      -1,  1, -1, -1, -1,  1, -1, -1,  1,  1, -1,  1,  1, -1,  1,  1, -1,   // C
      -1, -1,  1, -1, -1, -1,  1, -1,  1, -1,  1,  1, -1,  1,  1,  1, -1,   // G
      -1, -1, -1,  1,  1, -1, -1,  1, -1,  1,  1, -1,  1,  1,  1,  1, -1,   // T
      -1, -1, -1,  1,  1, -1, -1,  1, -1,  1,  1, -1,  1,  1,  1,  1, -1,   // U
      -1, -1, -1, -1, -1,  1, -1, -1, -1, -1, -1,  1,  1, -1, -1,  1, -1,   // M
      -1, -1, -1, -1, -1, -1,  1, -1, -1, -1, -1,  1, -1,  1, -1,  1, -1,   // R
      -1, -1, -1, -1, -1, -1, -1,  1, -1, -1, -1, -1,  1,  1, -1,  1, -1,   // W
      -1, -1, -1, -1, -1, -1, -1, -1,  1, -1, -1,  1, -1, -1,  1,  1, -1,   // S
      -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1, -1,  1, -1,  1,  1, -1,   // Y
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1, -1,  1,  1,  1, -1,   // K
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1, -1, -1,  1, -1,   // V
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1, -1,  1, -1,   // H
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1,  1, -1,   // D
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1, -1,   // B
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1,   // N
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // ?
    ];

    /// asymmetric: b1: A, b2: N will return 1, but b1: N, b2: A returns -1
    pub fn get(b1: u8, b2: u8) -> i8 {
        let i1 = Self::IDX[b1 as usize];
        let i2 = Self::IDX[b2 as usize];
        Self::MATRIX[(i1 as usize) * 17 + i2 as usize]
        // unsafe {
        //     let i1 = *Self::IDX.get_unchecked(b1 as usize);
        //     let i2 = *Self::IDX.get_unchecked(b2 as usize);
        //     *Self::MATRIX.get_unchecked((i1 as usize) * 17 + i2 as usize)
        // }
    }
}

#[cfg(test)]
mod tests {
    use super::AsymmIdentityDnaMatrix as M;

    #[test]
    fn test_async_dna_matrix() {
        assert_eq!(M::get(b'A', b'A'), 1);
        assert_eq!(M::get(b'T', b'T'), 1);
        assert_eq!(M::get(b'G', b'G'), 1);
        assert_eq!(M::get(b'C', b'C'), 1);
        assert_eq!(M::get(b'A', b'T'), -1);
        assert_eq!(M::get(b'T', b'N'), 1);
        assert_eq!(M::get(b'N', b'N'), 1);
        assert_eq!(M::get(b'U', b'T'), 1);
        assert_eq!(M::get(b'T', b'U'), 1);
        assert_eq!(M::get(b'G', b'S'), 1);
        assert_eq!(M::get(b'S', b'G'), -1);
        assert_eq!(M::get(b'S', b'N'), 1);
        assert_eq!(M::get(b'N', b'S'), -1);
        // non-uppercase (soft masked) characters
        assert_eq!(M::get(b'A', b'a'), -1);
        assert_eq!(M::get(b'a', b'A'), -1);
        assert_eq!(M::get(b'a', b'a'), -1);
        assert_eq!(M::get(b'a', b'N'), -1);
        assert_eq!(M::get(b'N', b'a'), -1);
    }
}
